# rj-thread-balancer
Балансировщик потоков

Балансировщик состоит из Supplier и Consumer блоков. 
Транзакция начинается в Supplier (получаем от куда-либо данные) и заканчивается в Consumer (как-то обрабатываем полученные данные).

Основные понятия:
1) Потоки крутят блок iteration, до тех пор, пока supplier не выдаст null, после чего поток уходит в паркинг или достигнут предел максимального кол-ва tps по Input и Output
2) 90% потоков, которые ушли в паркинг, при достижении новой секунды, возвращаются в пул исполения (run).
   Ну ведь так не бывает, что созданные потоки были просто так созданы.
   Происходит это в планировщике статистики, когда происходит агрегация за прошлую секунду
3) При условии коррекции TimeLag планировщик 3 раза в секунду восстанавливает работу припаркованных потоков (по одному) если не достигнут максимальный tps
4) Если в паркинге нет потоков - балансировщик наращивает потоки
5) Если в паркинге есть потоки, он проверяет когда, последний раз они просыпались и сколько итераций выполнили, в противном случае удаляет их

Обратите внимание:
1) Если интеграция внутри приклада управляйте самостоятельно wakeUp(), что бы балансировщик потоков вызвал блок supplier если все потоки находятся во сне 
2) Если интеграция внешняя и вам надо больше 1 раза в секунду проверять наличие информации, используйте setWakeUp3Times(true)
3) Если хотите замедлить в run time tps используйте setResistance(10) - уменьшит tps на 10% и будет каждую секунду вычитать -1% для возвращения к первичному состоянию

Ознакомьтесь с тестами, может быть станет понятнее