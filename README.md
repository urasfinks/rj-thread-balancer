# rj-thread-balancer
Балансировщик потоков

Балансировщик состоит из Supplier и Consumer блоков. На самом деле это всё синтетическое. 
Транзакция начинается в Supplier и заканчивается в Consumer. 
Единственное, что их различает это статистика.
Блоки могут работать на разных скоростях и они друг друга корректируют, так как сквозной tps- един.

Основы:
1) Потоки крутят блок iteration, до тех пор, пока supplier не выдатет null, после чего поток уходит в паркинг или достигнут предел максимального кол-ва tps (по Input и Output в любой последовательности)
2) 90% потоков, которые ушли в паркинг, при достяжении новой секунды, возвращаются в пул исполения (run).
   Ну ведь так не бывеет, что созданные потоки были просто так созданы.
   Происходит это в планировщике статистики, когда происходит агрегация за прошлую секунду
3) При условии коррекции TimeLag планировщик 3 раза в секунду восстанавливает работу припаркованных потоков (по одному) если не достигнут максимальны tps
4) Если в паркинге нет потоков - балансировщик наращивает потоки
4) Если в паркинге есть потоки, он проверяет когда, последний раз они просыпались и сколько итераций выполнили, в противном случаи удаляет их

Ясное дело, что там много различных проверок, но основа такова.

Балансировщик можно настроить по двум критериям:
1) Внешний источник - это когда input tps не зависит от предоставленных данных (supplierIdleInputTps = true).
   Самое главное мы сделали максимальное кол-во запросов во внешнюю среду, а получили или нет ответ - это уже другая история
2) Внутренний источник - это когда input tps зависит от получаемых данных (supplierIdleInputTps = false)
    А вот тут счётчик входных сообщений зависит только от полученных (не нулевых данных)

Что бы не задушить самого себя, при зависимости от внутренних русорсов следуйте правилам:

1) Используйте supplierIdleInputTps = false + setCorrectTimeLag(false); и управляйте самостоятельно wakeUpOnceThreadLast() 

Представляю какой это сумбур и какая каша в голове может быть от выше сказанного, но там всё структурировано, ознакомтесь с тестами.
(Я всё переосмысливал и переписывал из раза в раз, тут выдержка из вынесенного опыта очень большой компании, название которой останется в тени, нет ни одной строчки не скопировано, всё честно, это вынашивалось 8 лет) 

Также можно производить коррекцию не только в рамках одного балансировщика, но и в группе балансировщиков при помощи setResistance

Буду дополнять информацию постепенно
