# rj-thread-balancer
Балансировщик потоков

Балансировщик состоит из Supplier и Consumer блоков. 
Транзакция начинается в Supplier (получаем от куда-либо данные) и заканчивается в Consumer (как-то обрабатываем полученные данные).

Основные понятия:
1) Потоки крутят блок iteration, до тех пор, пока supplier не выдаст null, после чего поток уходит в паркинг или достигнут предел максимального кол-ва tps по Input и Output
2) 90% потоков, которые ушли в паркинг, при достижении новой секунды, возвращаются в пул исполения (run).
   Ну ведь так не бывает, что созданные потоки были просто так созданы.
   Происходит это в планировщике статистики, когда происходит агрегация за прошлую секунду
3) При условии коррекции TimeLag планировщик 3 раза в секунду восстанавливает работу припаркованных потоков (по одному) если не достигнут максимальный tps
4) Если в паркинге нет потоков - балансировщик наращивает потоки
5) Если в паркинге есть потоки, он проверяет когда, последний раз они просыпались и сколько итераций выполнили, в противном случае удаляет их

Если интеграция внутри приклада используйте setCorrectTimeLag(false) и управляйте самостоятельно wakeUp() 

Также можно производить коррекцию не только в рамках одного балансировщика, но и в группе балансировщиков при помощи setResistance

Ознакомьтесь с тестами, может быть станет понятнее